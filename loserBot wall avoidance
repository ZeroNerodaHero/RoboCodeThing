package robo;

import robocode.*;
import java.awt.Color;
import java.awt.geom.Point2D;

/**
 * A modular bot adhering to the RoboPart Interface.
 * 
 * @author TODO Your Name
 * @version TODO Date
 * 
 * @author Period - TODO Your Period
 * @author Assignment - PartsBot
 * 
 * @author Sources - TODO list collaborators
 */
public class PartsBot extends AdvancedRobot
{
    private AdvancedEnemyBot enemy = new AdvancedEnemyBot();
    
    private RobotPart[] parts = new RobotPart[3]; // make three parts
    private final static int RADAR = 0;
    private final static int GUN = 1;
    private final static int TANK = 2;
    
    
    
    
    
    //Create class Util
    public abstract class Util
    {
    //Create class Rectangle2D inside the Util class
        public abstract class Rectangle2D extends RectangularShape
        {
	    //Variable created for cotroling direction(1 or -1)
            static double direction;
	    //variable goalDirection
            double goalDirection = absBearing - Math.PI / 2 * direction;
	    //Use Rectangle2D to create a rectangle with x-coordinate, y-coordinate, width, height given
            Rectangle2D fieldRect = new Rectangle2D.Double(18, 18, getBattleFieldWidth() - 36, getBattleFieldHeight() - 36);
            while (! fieldRect.contains(getX() + Math.sin(goalDirection) * 120, getY() + Math.cos(goalDirection) * 120))
            {
                goalDirecion += direction * 0.1;
            }
            double turn = robocode.util.Utils.normalRelativeAngle(goalDirection - getHeadingRadians());
            if (Math.abs(turn) > Math.PI / 2)
            {
                turn = robocode.util.Utils.normalRelativeAngle(turn + Math.PI);
	            setBack(100);
            }
            else
            {
                setAhead(100);
            }
            setTurnRightRadians(turn);
        }
    }
    
    
    
    
    
    
    
    
    
    public void run()
    {
        parts[RADAR] = new Radar();
        parts[GUN] = new Gun();
        parts[TANK] = new Tank();

        // initialize each part
        for ( int i = 0; i < parts.length; i++ )
        {
            // behold, the magic of polymorphism
            parts[i].init();
        }

        // iterate through each part, moving them as we go
        for ( int i = 0; true; i = ( i + 1 ) % parts.length )
        {
            // polymorphism galore!
            parts[i].move();
            if ( i == 0 ) {
                execute();
            }
        }
    }
    
    public void onScannedRobot( ScannedRobotEvent e )
    {
        Radar radar = (Radar)parts[RADAR];
        if ( radar.shouldTrack( e ) ) {
            enemy.update( e, this );
        }
        //if the number of bots != 1 -> melee mode
        if(firemode != 1) {
            meleemode(e);
        } else {
            duelmode(e);
        }
    }

    //when the robot is in melee mode
    public void meleemode(ScannedRobotEvent e) {
        //run predictive_shooter()
        firemode = getOthers();
        if(getOthers == 1) {
            duelmode(e)
        }
    }
    //when the robot is in duel mode
    public void duelmode(ScannedRobotEvent e) {
        //run predictive_shooter()
        if(e.getlife <= 20) {
            //shoot things
            predictiveshooter();
        }
    }
    double absoluteBearing(double x1, double y1, double x2, double y2) 
    {
    	double xo = x2-x1;
	double yo = y2-y1;
	double hyp = Point2D.distance(x1, y1, x2, y2);
	double arcSin = Math.toDegrees(Math.asin(xo / hyp));
	double bearing = 0;
	if (xo > 0 && yo > 0) { // both pos: lower-Left
		bearing = arcSin;
	} else if (xo < 0 && yo > 0) { // x neg, y pos: lower-right
		bearing = 360 + arcSin; // arcsin is negative here, actually 360 - ang
	} else if (xo > 0 && yo < 0) { // x pos, y neg: upper-left
		bearing = 180 - arcSin;
	} else if (xo < 0 && yo < 0) { // both neg: upper-right
		bearing = 180 - arcSin; // arcsin is negative here, actually 180 + ang
	}

	return bearing;
    }
    public interface RobotPart
    {
        public void init();
        public void move();
    }
    
    public class Radar implements RobotPart
    {
        public void init()
        {
            setAdjustRadarForGunTurn(true);
        }
        public void move()
        {
            setTurnRadarRight(90);
        }
        public boolean shouldTrack( ScannedRobotEvent e )
        {
            // track if we have no enemy, the one we found is significantly
            // closer, or we scanned the one we've been tracking.
            return ( enemy.none() || e.getDistance() < enemy.getDistance() - 70
                || e.getName().equals( enemy.getName() ) );
        }
        public boolean wasTracking( RobotDeathEvent e )
        {
            return e.getName().equals( enemy.getName() );
        }
    }
}
